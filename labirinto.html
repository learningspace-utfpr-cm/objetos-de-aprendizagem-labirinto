<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <title>Labirinto com Lógica de Programação</title>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', sans-serif;
            background: #eef2f5;
            color: #333;
            overflow: hidden;
        }

        /* HEADER */
        header {
            position: absolute;
            top: 10px;
            left: 2.5%;
            width: 95%;
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            z-index: 100;
            box-sizing: border-box;
            padding: 0 20px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            min-width: 100px;
            justify-content: flex-end;
        }

        #levelButtons {
            display: flex;
            gap: 8px;
            /* Espaço entre botões */
            justify-content: center;
            /* Centraliza os botões */
            flex-grow: 1;
            /* Ocupa todo o espaço disponível no meio */
            margin: 0 20px;
            /* Margem para não colar no título/contador */
            flex-wrap: wrap;
            /* Se tiver muitos, quebra linha (sem scroll) */
        }

        .level-btn {
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ddd;
            background-color: #f0f2f5;
            border-radius: 50%;
            /* Deixa redondinho */
            cursor: pointer;
            font-weight: bold;
            color: #555;
            transition: all 0.2s;
            font-size: 14px;
            padding: 0;
            /* Remove padding interno para centralizar texto */
        }

        .level-btn:hover {
            background-color: #e0e0e0;
            transform: scale(1.1);
        }

        .level-btn.active {
            background-color: #42A5F5;
            color: white;
            border-color: #42A5F5;
            box-shadow: 0 3px 8px rgba(66, 165, 245, 0.4);
            transform: scale(1.15);
        }

        #blockCounter {
            font-weight: bold;
            color: #555;
            font-size: 14px;
            min-width: 80px;
            text-align: right;
        }

        .limit-exceeded {
            color: #d32f2f !important;
        }

        /* CONTAINER */
        #container {
            position: absolute;
            top: 80px;
            bottom: 70px;
            left: 2.5%;
            right: 2.5%;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: block;
        }

        #gameArea {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 40%;
            background-color: #f9f9f9;
            border-right: 1px solid #ddd;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #mapWrapper {
            position: relative;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            background: white;
        }

        #blocklyDiv {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 60%;
            background-color: #fff;
        }

        /* CONTROLS */
        #controls {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            height: 50px;
            z-index: 100;
        }

        button {
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            transition: transform 0.1s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: scale(0.98);
        }

        #btnRun {
            background: #42A5F5;
            color: white;
        }

        #btnReset {
            background: #EF5350;
            color: white;
        }

        /* GAME ASSETS */
        .cell {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 1px solid #eee;
            box-sizing: border-box;
        }

        .wall {
            background-color: #546E7A;
        }

        .path {
            background-color: #fff;
        }

        .goal {
            background-color: #66BB6A;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
        }

        #player {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #FF7043;
            border-radius: 8px;
            transition: all 0.2s linear;
            z-index: 10;
            top: 5px;
            left: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #player::after {
            content: '▲';
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            transform: rotate(90deg);
        }

        /* CARD-INFO */
        #tutorialOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .tutorial-box {
            background: white;
            padding: 30px;
            border-radius: 12px;
            width: 500px;
            max-width: 90%;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            animation: popIn 0.3s ease;
        }

        .tutorial-box h2 {
            margin-top: 0;
            color: #2196F3;
        }

        .tutorial-box p {
            font-size: 18px;
            line-height: 1.5;
            color: #444;
        }

        .tutorial-box button {
            background: #4CAF50;
            color: white;
            margin-top: 20px;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes shake {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            50% {
                transform: translateX(5px);
            }

            75% {
                transform: translateX(-5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        .shake-error {
            animation: shake 0.4s ease-in-out;
            background-color: #d32f2f !important;
            box-shadow: 0 0 10px #d32f2f !important;
        }

        .shake-success {
            animation: shake 0.5s ease-in-out;
            background-color: #388E3C !important;
            box-shadow: 0 0 10px #388E3C !important;
            transform: scale(1.1);
        }

        .trap {
            background-color: #FFEB3B;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        #btnHint {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            border: 2px solid #ddd;
            color: #2196F3;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            z-index: 500;
            /* Para ficar acima do mapa e do player */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        #btnHint:hover {
            transform: scale(1.1);
            border-color: #2196F3;
        }
    </style>
</head>

<body>

    <div id="tutorialOverlay">
        <div class="tutorial-box">
            <h2 id="tutorialTitle">Info</h2>
            <p id="tutorialText">...</p>
            <button onclick="closeTutorial()">Entendi</button>
        </div>
    </div>

    <header>
        <h1>Labirinto</h1>
        <div id="levelButtons"></div>
        <div class="status-bar">
            <div id="blockCounter">Blocos: 0/0</div>
        </div>
    </header>

    <div id="container">
        <button id="btnHint" onclick="openHint()">?</button>
        <div id="gameArea">
            <div id="player"></div>
        </div>
        <div id="blocklyDiv"></div>
    </div>

    <div id="controls">
        <button id="btnRun" onclick="runCode()">▶ Executar</button>
        <button id="btnReset" onclick="resetLevel()" style="display: none;">↻ Reiniciar</button>
    </div>

    <script>
        const TILE_SIZE = 50;

        // --- DESIGN DE NÍVEIS ---
        const levels = [
            {
                name: "1",
                // Objetivo: Entender os blocos básicos.
                map: [
                    [1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 3, 1],
                    [1, 1, 1, 1, 0, 1],
                    [1, 2, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1]],
                startPos: { x: 1, y: 3 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right"], maxBlocks: 6,
                tutorial: { title: "Nível 1", text: "Bem-vindo ao labirinto! Use os blocos <b>Avançar</b>, <b>Virar à Esquerda</b> e <b>Virar à Direita</b> para chegar à estrela." }
            },
            {
                name: "2",
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                ],
                startPos: { x: 1, y: 1 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right"], maxBlocks: 5,
                tutorial: { title: "Nível 2", text: "Ótimo trabalho! O próximo parece até mais fácil." }
            },
            {
                name: "3",
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                ],
                startPos: { x: 1, y: 1 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal"], maxBlocks: 2,
                tutorial: { title: "Nível 3", text: "Bom trabalho! Mas você pode fazer melhor usando o bloco de repetição." }
            },
            {
                name: "4",
                map: [
                    [1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 1],
                    [1, 1, 1, 1, 0, 1],
                    [1, 1, 1, 1, 0, 1],
                    [1, 3, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 1, y: 1 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal", "if_path"], maxBlocks: 4,
                tutorial: { title: "Nível 4", text: "Agora as coisas estão ficando interessantes! Use o bloco <b>Se caminho</b> para decidir a direção correta." }
            },
            {
                name: "5",
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 3, 0, 0, 0, 1, 1, 1],
                    [1, 1, 1, 1, 0, 1, 1, 1],
                    [1, 1, 4, 1, 0, 0, 4, 1],
                    [1, 1, 0, 1, 0, 1, 1, 1],
                    [1, 2, 0, 0, 0, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                ],
                startPos: { x: 1, y: 5 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal", "if_path", "if_else_path"], maxBlocks: 5,
                tutorial: { title: "Nível 5", text: "Cuidado com as armadilhas amarelas. Use o bloco <b>Se caminho... senão</b> para tomar a decisão correta." }

            },
            {
                name: "6",
                // O Escadão: Exige um loop de movimento e virada
                map: [
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 3, 1],
                    [1, 1, 1, 1, 0, 0, 1],
                    [1, 1, 1, 0, 0, 1, 1],
                    [1, 1, 0, 0, 1, 1, 1],
                    [1, 2, 0, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 1, y: 5 }, startDir: 1, // Começa olhando para direita
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal"], maxBlocks: 5,
                tutorial: { title: "Nível 6 (Extra)", text: "Uma escada! Você consegue criar um padrão de movimentos que se repete para subir?" }
            },
            {
                name: "7",
                // O Labirinto Cego: Exige verificar laterais
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 3, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1],
                    [1, 2, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 1, y: 5 }, startDir: 0, // Começa olhando para CIMA
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal", "if_else_path"], maxBlocks: 5,
                tutorial: { title: "Nível 7 (Extra)", text: "Labirinto complexo. Tente a regra da 'mão direita': Se houver caminho à direita, vire. Senão, avance." }
            }

        ];

        let currentLevelIndex = 0;
        let map = [], playerPos = { x: 0, y: 0 }, playerDir = 1, commandQueue = [], isRunning = false;
        let simPos = { x: 0, y: 0 }, simDir = 1, protectionCounter = 0, simHitWall = false;
        let animationTimer = null;

        // Blockly Defs
        Blockly.defineBlocksWithJsonArray([
            { "type": "move_forward", "message0": "Avançar ⬆", "previousStatement": null, "nextStatement": null, "colour": 160, },
            { "type": "turn_left", "message0": "Virar Esquerda ↺", "previousStatement": null, "nextStatement": null, "colour": 160 },
            { "type": "turn_right", "message0": "Virar Direita ↻", "previousStatement": null, "nextStatement": null, "colour": 160 },
            { "type": "repeat_until_goal", "message0": "Repetir até chegar em ★ %1 %2", "args0": [{ "type": "input_dummy" }, { "type": "input_statement", "name": "DO" }], "previousStatement": null, "nextStatement": null, "colour": 290 },

            {
                "type": "if_path",
                "message0": "Se caminho à %1 %2 %3",
                "args0": [
                    {
                        "type": "field_dropdown",
                        "name": "DIR",
                        "options": [
                            ["frente ⬆", "ahead"],
                            ["esquerda ↺", "left"],
                            ["direita ↻", "right"]
                        ]
                    },
                    { "type": "input_dummy" },
                    { "type": "input_statement", "name": "DO" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": 210
            },
            {
                "type": "if_else_path",
                "message0": "Se caminho à %1 %2 %3 senão %4",
                "args0": [
                    {
                        "type": "field_dropdown",
                        "name": "DIR",
                        "options": [
                            ["frente ⬆", "ahead"],
                            ["esquerda ↺", "left"],
                            ["direita ↻", "right"]
                        ]
                    },
                    { "type": "input_dummy" },
                    { "type": "input_statement", "name": "DO" },
                    { "type": "input_statement", "name": "ELSE" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": 210
            }
        ]);

        javascript.javascriptGenerator.forBlock['move_forward'] = function (block) { return 'simulationMove("' + block.id + '");\n'; };
        javascript.javascriptGenerator.forBlock['turn_left'] = function (block) { return 'simulationTurn(-1, "' + block.id + '");\n'; };
        javascript.javascriptGenerator.forBlock['turn_right'] = function (block) { return 'simulationTurn(1, "' + block.id + '");\n'; };
        javascript.javascriptGenerator.forBlock['repeat_until_goal'] = function (block) {
            var branch = javascript.javascriptGenerator.statementToCode(block, 'DO');
            return 'while (!simulationIsGoal() && !simHitWall && ++protectionCounter < 2000) {\n' + branch + '}\n';
        };
        javascript.javascriptGenerator.forBlock['if_path'] = function (block) {
            var dropdown_dir = block.getFieldValue('DIR'); // Pega o valor selecionado
            var branch = javascript.javascriptGenerator.statementToCode(block, 'DO');
            // Passamos o valor (ex: 'left') para a função JS
            return 'if (simulationPath("' + dropdown_dir + '")) {\n' + branch + '}\n';
        };

        javascript.javascriptGenerator.forBlock['if_else_path'] = function (block) {
            var dropdown_dir = block.getFieldValue('DIR');
            var branch = javascript.javascriptGenerator.statementToCode(block, 'DO');
            var branchElse = javascript.javascriptGenerator.statementToCode(block, 'ELSE');
            return 'if (simulationPath("' + dropdown_dir + '")) {\n' + branch + '} else {\n' + branchElse + '}\n';
        };

        const workspace = Blockly.inject('blocklyDiv', {
            toolbox: { "kind": "flyoutToolbox", "contents": [] },
            maxBlocks: Infinity,
            scrollbars: true,
            trashcan: true,
            zoom: {
                controls: true,
                wheel: true,
                startScale: 1.0,
                maxScale: 3,
                minScale: 0.6,
                scaleSpeed: 1.2
            }
        });

        // Resize handler
        function onResize() {
            var element = document.getElementById('blocklyDiv');
            Blockly.svgResize(workspace);
        }
        window.addEventListener('resize', onResize, false);
        setTimeout(onResize, 100);

        workspace.addChangeListener(() => updateBlockCounter());

        const levelContainer = document.getElementById("levelButtons");

        levels.forEach((lvl, index) => {
            let btn = document.createElement("button");
            btn.className = "level-btn";
            btn.innerText = index + 1;
            btn.title = lvl.name;
            btn.onclick = () => loadLevel(index);
            levelContainer.appendChild(btn);
        });

        function loadLevel(index) {
            if (index >= levels.length) { alert("PARABÉNS! VOCÊ ZEROU TUDO!"); index = 0; }
            currentLevelIndex = index;

            const buttons = document.querySelectorAll('.level-btn');
            buttons.forEach((btn, i) => {
                if (i === index) {
                    btn.classList.add('active');
                    btn.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                } else {
                    btn.classList.remove('active');
                }
            });

            document.getElementById('btnRun').style.display = 'inline-block';
            document.getElementById('btnReset').style.display = 'none';

            const tutBtn = document.querySelector('.tutorial-box button');
            tutBtn.innerText = 'Entendi';
            tutBtn.onclick = closeTutorial;

            const level = levels[index];
            map = level.map;
            playerPos = { ...level.startPos }; playerDir = level.startDir;
            workspace.options.maxBlocks = level.maxBlocks;
            updateToolbox(level.blocks);
            workspace.clear();
            drawMap();
            resetLevelVariables();
            updateBlockCounter();
            setTimeout(onResize, 50);
        }

        function updateToolbox(allowedBlocks) {
            const toolboxContents = allowedBlocks.map(type => ({ "kind": "block", "type": type }));
            workspace.updateToolbox({ "kind": "flyoutToolbox", "contents": toolboxContents });
        }

        function updateBlockCounter() {
            const max = workspace.options.maxBlocks;
            const used = workspace.getAllBlocks(false).length;
            const counterEl = document.getElementById("blockCounter");
            counterEl.innerText = `Blocos: ${used}/${max}`;
            if (used > max) counterEl.classList.add("limit-exceeded");
            else counterEl.classList.remove("limit-exceeded");
        }

        function showTutorial(tutorialData) {
            if (!tutorialData) return;
            document.getElementById('tutorialTitle').innerText = tutorialData.title;
            document.getElementById('tutorialText').innerHTML = tutorialData.text;
            document.getElementById('tutorialOverlay').style.display = 'flex';
        }
        function closeTutorial() { document.getElementById('tutorialOverlay').style.display = 'none'; }

        const gameArea = document.getElementById('gameArea');
        function drawMap() {
            gameArea.innerHTML = '';
            const mapHeightPx = map.length * TILE_SIZE;
            const mapWidthPx = map[0].length * TILE_SIZE;

            const mapWrapper = document.createElement('div');
            mapWrapper.id = 'mapWrapper';
            mapWrapper.style.width = mapWidthPx + 'px';
            mapWrapper.style.height = mapHeightPx + 'px';
            mapWrapper.style.position = 'relative';

            const playerDiv = document.createElement('div');
            playerDiv.id = 'player';
            mapWrapper.appendChild(playerDiv);

            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let cell = document.createElement('div');
                    let type = map[y][x];

                    let classType = 'path';
                    if (type === 1) classType = 'wall';
                    if (type === 3) classType = 'goal';
                    if (type === 4) classType = 'trap';

                    cell.className = 'cell ' + classType;

                    if (type === 3) cell.innerHTML = '★';

                    cell.style.top = (y * TILE_SIZE) + 'px';
                    cell.style.left = (x * TILE_SIZE) + 'px';

                    mapWrapper.appendChild(cell);
                }
            }

            gameArea.appendChild(mapWrapper);

            updatePlayerVisual(playerDiv, playerPos.x, playerPos.y, playerDir);
        }

        function updatePlayerVisual(el, x, y, dir) {
            if (!el) return;
            el.style.top = (y * TILE_SIZE + 5) + 'px';
            el.style.left = (x * TILE_SIZE + 5) + 'px';
            const rotation = (dir * 90) - 90;
            el.style.transform = `rotate(${rotation}deg)`;
        }

        function simulationMove(blockId) {
            if (simHitWall) return;
            let nextX = simPos.x, nextY = simPos.y;
            if (simDir === 0) nextY--;
            if (simDir === 1) nextX++;
            if (simDir === 2) nextY++;
            if (simDir === 3) nextX--;

            if (map[nextY] && map[nextY][nextX] !== undefined) {
                const tileType = map[nextY][nextX];

                if (tileType === 1) {
                    simHitWall = true;
                    commandQueue.push({ action: "bonk", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
                } else if (tileType === 4) {
                    simPos.x = nextX; simPos.y = nextY;
                    commandQueue.push({ action: "move", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
                    simHitWall = true;
                    commandQueue.push({ action: "bonk", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
                } else {
                    simPos.x = nextX; simPos.y = nextY;
                    commandQueue.push({ action: "move", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });

                }
            } else {
                simHitWall = true;
                commandQueue.push({ action: "bonk", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
            }
        }

        function simulationTurn(direction, blockId) {
            if (simHitWall) return;
            if (direction === -1) simDir = (simDir + 3) % 4; else simDir = (simDir + 1) % 4;
            commandQueue.push({ action: "turn", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
        }

        function simulationIsGoal() { return map[simPos.y][simPos.x] === 3; }

        function simulationPath(relativeDir) {
            let checkDir = simDir;
            if (relativeDir === "left") {
                checkDir = (simDir + 3) % 4;
            } else if (relativeDir === "right") {
                checkDir = (simDir + 1) % 4;
            }
            let cx = simPos.x, cy = simPos.y;
            if (checkDir === 0) cy--; // Cima
            if (checkDir === 1) cx++; // Direita
            if (checkDir === 2) cy++; // Baixo
            if (checkDir === 3) cx--; // Esquerda
            return (map[cy] && map[cy][cx] !== 1);
        }

        function runCode() {
            if (isRunning) return;
            if (workspace.getAllBlocks(false).length > workspace.options.maxBlocks) {
                alert(`Limite de blocos excedido!`); return;
            }

            document.getElementById('btnRun').style.display = 'none';
            document.getElementById('btnReset').style.display = 'inline-block';

            resetLevelVariables();
            simPos = { ...playerPos }; simDir = playerDir; protectionCounter = 0; simHitWall = false; isRunning = true;
            const code = javascript.javascriptGenerator.workspaceToCode(workspace);
            try {
                eval(code);
                if (commandQueue.length === 0) isRunning = false; else processQueue();
            } catch (e) { alert("Erro: " + e); isRunning = false; }
        }

        function processQueue() {
            const p = document.getElementById('player');
            if (commandQueue.length === 0) {
                workspace.highlightBlock(null);
                if (map[playerPos.y][playerPos.x] === 3) {
                    p.classList.remove('shake-success');
                    void p.offsetWidth;
                    p.classList.add('shake-success');
                    setTimeout(() => {
                        if (currentLevelIndex + 1 < levels.length) {
                            loadLevel(currentLevelIndex + 1);
                        } else {
                            showVictoryScreen();
                        }
                    }, 1500);
                } else {
                    p.classList.remove('shake-error');
                    void p.offsetWidth;
                    p.classList.add('shake-error');
                }
                isRunning = false; return;
            }
            const cmd = commandQueue.shift();
            if (cmd.blockId) {
                workspace.highlightBlock(cmd.blockId);
            }
            playerPos.x = cmd.x; playerPos.y = cmd.y; playerDir = cmd.dir;
            updatePlayerVisual(p, playerPos.x, playerPos.y, playerDir);
            if (cmd.action === "bonk") {
                p.classList.remove('shake-error');
                void p.offsetWidth;
                p.classList.add('shake-error');
            }
            animationTimer = setTimeout(processQueue, 450);
        }

        function resetLevel() {
            document.getElementById('btnRun').style.display = 'inline-block';
            document.getElementById('btnReset').style.display = 'none';

            resetLevelVariables();
        }

        function resetLevelVariables() {
            if (animationTimer) clearTimeout(animationTimer);

            const level = levels[currentLevelIndex];
            playerPos = { ...level.startPos }; playerDir = level.startDir;
            commandQueue = []; isRunning = false; simHitWall = false;
            const p = document.getElementById('player');
            p.classList.remove('shake-error');
            p.classList.remove('shake-success');
            workspace.highlightBlock(null);
            updatePlayerVisual(document.getElementById('player'), playerPos.x, playerPos.y, playerDir);
        }

        function showVictoryScreen() {
            document.getElementById('tutorialTitle').innerText = "Parabéns!";
            document.getElementById('tutorialText').innerHTML = "<b>Você zerou o Labirinto!</b><br><br>Você dominou todos os algoritmos.";

            const btn = document.querySelector('.tutorial-box button');
            btn.innerText = "Voltar ao Início";
            btn.onclick = function () {
                closeTutorial();
                loadLevel(0);
            };

            document.getElementById('tutorialOverlay').style.display = 'flex';
        }

        function openHint() {
            const tutBtn = document.querySelector('.tutorial-box button');
            tutBtn.innerText = 'Entendi';
            tutBtn.onclick = closeTutorial;

            // Pega os dados do nível atual
            const tutorialData = levels[currentLevelIndex].tutorial;

            if (tutorialData) {
                showTutorial(tutorialData);
            }
        }

        loadLevel(0);
    </script>
</body>

</html>